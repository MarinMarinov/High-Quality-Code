# Iterator Pattern

## Мотивация
Необходимостта от отделяне на логиката по обхождането на дадена структура от логиката за обработване на данните на самата структура.

 
## Цел
* Достъп до елементите на сложен обект(колекция) без за това да е необходимо разкриването на имплементацията на този обект
* Съществуват различни начини обхождане на структури от данни
	* Детайлите по обхождането остават скрити
	* Алгоритмите по обхождането са взаимозаменяеми
* Предоставя унифициран абстрактен интерфейс за обхождане на различни видове структури от данни.

## Приложение
![](Iterator1.jpg)

Това е принципното имплементиране na **Iterator pattern** в езици извън .NET платформата.
Интерфейсът Iterator има метод Next(), който ще дава всеки следващ елемент в колекцията. Iterator, също така може да зададе и логиката за обхождане на колекцията. Aggregate и ConcreteAggredate са, съответно, интерфейсът даващ ни абстракцията на колекцията и класът имплементиращ конкретната колекция. Класът ConcreteIterator имплементира конкретната логика на интерфейса за колекцията. Конкретните имплементатори могат да са няколко, да речем, за няколко различни колекции от тип Tree, но те ще се обхождат по еднакъв начин.
 

## Известни употреби
В .NET **Iterator** шаблонът е директно имплементиран чрез интерфейс под наименованието **IEnumerator**. В резултат във всяка една колекция в .NET, която може да се обхожда е имплементиран този интерфейс. Цикълът за обхождане Foreach използва именно този шаблон. Ключовата дума yield генерира автоматично enumerator. 

## Имплементация в .NET
// Интерфейс на итератора

	public interface IEnumerator { // Iterator
	   bool MoveNext();
	   object Current { get; }
	   void Reset();
	}

Методът MoveNext() отива на следващият елемент в колекцията(следващият по индекс при линейните колекциии(масивите), или следващият наследник вляво/вдясно при дърветата). Пропъртито Current ни връща текущият елемент. Методът Reset()(ако е имплементиран, радко се използва) ни връща в началото на масива(при корена на дървото), ако сме използвали вече енумератора и искаме втори път да използваме същият енумератор. Прилича на Object Pool шаблона.

// Интерфейс на колекцията

	public interface IEnumerable { // Aggregate interface
	   IEnumerator GetEnumerator();
	}
IEnumerable е интерфейсът на колекцията, която (ще) може да бъде обхождана чрез методите на IEnumerator. Дава ни метод GetEnumerator(), който ни връща IEnumerator. По този начин самата колекция определя кой е нейният Enumerator

// Конкретен клас имплементиращ IEnumerator

	private class ConcreteEnumerator : IEnumerator {
	   // Implement IEnumerator interface
	}

Всяка колекция от този клас ще имплементира колекция IEnumerable  с обхождане IEnumerator


// Конкретна имплементация на клас за обхождане -  в случая foreach

	var enumerator = someObject.GetEnumerator();

	while (enumerator.MoveNext()) {
	   // work with enumerator.Current
	}

// Използваме foreach

	foreach(var item in collection){
		// some code here
	}

В случая **collection** фактически е обектът **enumerator**, който сме получили чрез **someObject.GetEnumerator()**, а **item** е това, което ни връща **enumerator.Current()**

## Последствия
* Имплементирайки един и същ интерфейс, можем да обхождаме различни видове структури.
* Можем да имплементираме различни Iterator-и и да ги изпозлваме върху различни колекции
* Благодарение на вграденият IEnumerable интерфейс в .NET, всички колекции, го имплементират, без да е необходимо да правим собствен Iterator.


